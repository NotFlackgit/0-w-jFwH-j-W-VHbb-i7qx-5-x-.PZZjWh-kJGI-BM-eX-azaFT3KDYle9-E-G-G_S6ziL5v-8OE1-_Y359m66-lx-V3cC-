names = [
    "Люмин", "Эмбер", "Чжун Ли", "Гань Юй", "Тарталья", "Нин Гуан", "Сяо", 
    "Ци Ци", "Кэйа", "Синь Янь", "Аято", "Кэ Цин", "Беннет", "Мона", 
    "Яэ Мико", "Альбедо", "Скарамучча", "Фишль", "Ноэль", "Синьцю", "Рэйзор"
]

weapons = [
    "меч", "щит", "лук", "арбалет", "копье", "палица", "топор", "сабля", 
    "боевой молот", "алебарда", "кикери", "катана", "дага", "крюк", "ястребинный меч",
    "двойные кинжалы", "боевой топор", "секира", "рапира", "меч с проклятой рукояткой",
    "меч дракона", "цепи", "глефа", "древний посох", "меч с рунами", "алебарда с лезвием черного металла",
    "стрелы с магическим наконечником", "теневая сабля", "гарпун", "метательные звезды", "джаггернаут",
    "громовой топор", "рукоятка змеи", "небесный меч", "шипы из адского железа"
]

magical_items = [
    "чаша судьбы", "плащ невидимости", "посох древнего магистра", 
    "камень всеведущего", "книга заклинаний", "кристалл мудрости", 
    "сфера времени", "заклинательный амулет", "волшебный жезл",
    "кристалл вечности", "амулет душ", "перо феникса", "зеркало истины",
    "зачарованный мантия", "талисман удачи", "чашка бесконечности", "куб бесконечного знания",
    "саркофаг времени", "перстень крови", "медальон врат", "свиток древних знаний", 
    "шар ясновидения", "печать демона", "кубок маны", "тотем духа", "лунный амулет",
    "ожерелье стихий", "книга пророчеств", "шлем Тёмного мага"
]

titles = [
    "рыцарь", "маг", "воин", "шаман", "лучник", "колдун", "разведчик", "воевода", "принц", 
    "король", "палач", "странник", "владыка", "разрушитель", "целитель", "тиран", "победитель", 
    "покоритель", "паломник", "священник", "капитан", "предатель", "тень", "старейшина", "чародей", 
    "легенда", "провидец", "сказочник", "ветеран", "древний", "воин-странник", "магистр", "чародей-эксперт", 
    "повелитель", "темный маг", "мастер меча", "повелитель стихий", "потомок богов", "железный рыцарь", 
    "покровитель", "посланник", "парашютист", "мститель", "следопыт", "король магии", "кровавый маг", 
    "покоритель миров", "охотник на демонов", "демоноборец", "архимаг", "повелитель темных сил", "мудрец", 
    "психолог", "механик", "генерал", "эксперт по алхимии", "прикрытие", "авантюрист", "повелитель природы", 
    "страж", "странствующий маг", "воин света", "предвестник", "древний страж", "царь зверей", "повелитель времени"
]

facts = [
    "Пчёлы могут узнавать лица людей.",
    "Самая длинная река в мире — Амазонка.",
    "Осьминоги имеют три сердца.",
    "Молоко бегемота розового цвета.",
    "Самая высокая гора на Земле — это Эверест.",
    "Космос официально начинается на высоте 100 км над Землёй.",
    "Луна отдаляется от Земли на 3,8 см каждый год.",
    "У бабочек вкусовые рецепторы находятся на лапках.",
    "Самая холодная температура на Земле была зафиксирована в Антарктиде: -89,2°C.",
    "Глаза страуса больше, чем его мозг.",
    "Человеческий мозг потребляет около 20% энергии тела.",
    "Пингвины могут пить солёную воду благодаря специальной железе.",
    "Акулы существуют на Земле более 400 миллионов лет.",
    "Скорость звука в воде в четыре раза больше, чем в воздухе.",
    "Золотая медуза в озере Палау не умеет жалить.",
    "Самая глубокая точка в океане — Марианская впадина, глубина 10 994 метра.",
    "В среднем человек проходит за жизнь расстояние, равное 5 экваторам Земли.",
    "Коровы могут чувствовать магнитное поле Земли и выстраиваться по его линиям.",
    "Муравьи никогда не спят, и у них нет лёгких.",
    "Дерево баобаб может хранить до 120 000 литров воды.",
    "Слоны — единственные животные, которые не могут прыгать.",
    "Язык синего кита весит больше, чем взрослый слон.",
    "Гепард может разогнаться до 120 км/ч за 3 секунды.",
    "Летучие мыши — единственные млекопитающие, которые могут летать.",
    "Самая древняя мумия была найдена в Чили и её возраст около 7 000 лет.",
    "В космосе нет звуков, потому что нет воздуха для передачи звука.",
    "Человеческое сердце делает примерно 100 000 ударов в день.",
    "Жирафы спят всего около 2 часов в сутки.",
    "Морская звезда может регенерировать потерянные конечности.",
    "Песчаные дюны могут «петь» при определённых условиях.",
    "Кровь крабов голубого цвета из-за наличия меди.",
    "Одна чайная ложка нейтронной звезды весит около 6 миллиардов тонн.",
    "Осьминоги могут менять цвет в зависимости от настроения.",
    "Планета Венера вращается в обратную сторону по сравнению с другими планетами.",
    "Вода замерзает быстрее, если она горячая — это называется эффектом Мпембы.",
    "Молоко в океане может образоваться из-за миллиардов маленьких светящихся бактерий.",
    "Землетрясение может вызывать резонанс в кольцах Сатурна.",
    "На Марсе закаты кажутся синими.",
    "Каждую минуту Земля получает от Солнца энергию, которой хватило бы на целый год.",
    "Космический аппарат Voyager 1 находится на расстоянии более 22 миллиардов километров от Земли.",
    "У улиток может быть до 14 000 зубов.",
    "Рога носорога состоят из кератина — того же белка, что и человеческие волосы.",
    "Самый маленький рептилий в мире — хамелеон Brookesia micra, длиной всего 2,5 см.",
    "Муравьи способны поднять вес, превышающий их собственный в 50 раз.",
    "Скорость вращения Земли медленно замедляется из-за влияния Луны.",
    "Факт о Солнце: оно составляет 99,86% массы всей Солнечной системы.",
    "Скорпион может прожить без еды до одного года.",
    "Человеческий глаз может различать около 10 миллионов оттенков цветов.",
    "Атмосфера Земли на 78% состоит из азота.",
    "Волны океана могут достигать высоты более 30 метров.",
    "В средневековье кошки считались символом удачи."
]















import os
import telebot
from telebot import types
from telebot.types import InlineKeyboardButton, InlineKeyboardMarkup
import threading
os.system('pip install asyncio')
import asyncio
os.system('pip install pytz')
import pytz
from datetime import datetime, timedelta
import requests
import random
import sqlite3
import time
import aiohttp




COOLDOWN_TIME = 3
last_used_time = {}  


TOKEN = '7686912609:AAG6WXKI1RfwCZtQ04HBPBEbruXbNXkNPvw'
bot = telebot.TeleBot(TOKEN)

LOG_CHAT_ID = "-1002168101294"
owners = [5735189388, 1411680390]  


















OWNER_ID = 5735189388 
FAVORITE_ID = 1411680390 
cooldowns = {}
current_pairs = {}

@bot.message_handler(commands=['pair'])
def pair_handler(message):
    chat_id = message.chat.id
    now = datetime.now()

    # Проверка на наличие активного кулдауна
    if chat_id in cooldowns:
        last_used_time = cooldowns[chat_id]
        if now - last_used_time < timedelta(days=1):
            first_user, second_user = current_pairs[chat_id]
            bot.reply_to(message, f"💞 Пара дня уже: {first_user} и {second_user}. Мур мяу, живите дружно!")
            return

    try:
        members = bot.get_chat_administrators(chat_id)
        members = [admin.user for admin in members]

        if len(members) < 2:
            bot.reply_to(message, "Недостаточно участников для выбора пары.")
            return

        # Поиск владельца и любимой
        owner = next((m for m in members if m.id == OWNER_ID), None)
        favorite = next((m for m in members if m.id == FAVORITE_ID), None)
        
        pair = random.sample(members, 2)
        first_user = pair[0].first_name
        second_user = pair[1].first_name

        current_pairs[chat_id] = (first_user, second_user)
        bot.send_message(chat_id, f"💓 Пара дня: {first_user} и {second_user}. Мур мяу, живите дружно!")

        cooldowns[chat_id] = now  # Сохраняем время использования команды

    except Exception as e:
        bot.reply_to(message, "Ошибка при выборе пары.")
        print(f"Ошибка: {e}")

@bot.message_handler(commands=["own"])
def remove_buttons(message):
    if message.from_user.id in owners:
    	bot.send_message(message.chat.id, "Вы состоите в списке доступа.")
    else:
    	bot.send_message(message.chat.id, "Вы не состоите в списке доступа.")



@bot.message_handler(commands=['rmbt'])
def remove_buttons(message):
    """
    Удаляет клавиатуру с кнопками, если пользователь в списке владельцев.
    """
    if message.from_user.id in owners:
        markup = types.ReplyKeyboardRemove()  # Удаляем клавиатуру
        bot.send_message(message.chat.id, "Кнопки удалены.", reply_markup=markup)
    else:
    	bot.send_message(message.chat.id, "Команда недоступна. Вы не состоите в списке владельцев бота.")














@bot.message_handler(commands=['ahelp'])
def ahelp(message):
    user_id = message.from_user.id
    cooldown = cooldown_handler(user_id)

    if cooldown is not None:
        bot.reply_to(message, f"Подождите {cooldown} секунд.")
        return
    log_to_telegram(message)
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    print("/ahelp")
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    help_text = (
        "ℹ️ *Список доступных команд:* \n\n"
        "/start - Начать взаимодействие с ботом.\n"
        "/ping - Проверить связь с ботом.\n"
        "/gs - Угадай число от 1 до 100.\n"
        "/rlt - Играй в русскую рулетку.\n"
        "/hero - Получи случайного персонажа с оружием и магическим предметом.\n"
        "/love @username - Узнай совместимость с другим пользователем.\n"
        "/time - Получи время во всех часовых поясах мира.\n"
        "/stats - Посмотреть свою статистику.\n"
        "/actions — курсы биткойна и доллара в гривнах, тенге и рублях\n"
        "Просто напишите команду, чтобы узнать о ней больше!"
    )
    bot.reply_to(message, help_text)

def cooldown_handler(user_id):
    """Проверка на кулдаун для пользователя с использованием datetime."""
    current_time = datetime.now()  # Получаем текущее время
    last_used = last_used_time.get(user_id, None)

    if last_used and current_time - last_used < timedelta(seconds=COOLDOWN_TIME):
        remaining_time = (last_used + timedelta(seconds=COOLDOWN_TIME)) - current_time
        return remaining_time.seconds  # Возвращаем оставшееся время кулдауна в секундах
    else:
        last_used_time[user_id] = current_time  # Обновляем время последнего использования
        return None
        
        



# Логирование в Telegram
def log_to_telegram(message):
    user = message.from_user
    log_entry = (
        f"Дата и время: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        f"Имя: {user.first_name} {user.last_name or ''}\n"
        f"Юзернейм: @{user.username or 'нет'}\n"
        f"ID пользователя: {user.id}\n"
        f"ID link: tg://user?id={user.id}\n"
        f"Команда: {message.text}/n"
        f"Конец лога----"
    )
    bot.send_message(LOG_CHAT_ID, log_entry)



@bot.message_handler(commands=['start'])
def send_welcome(message):
    user_id = message.from_user.id
    cooldown = cooldown_handler(user_id)

    if cooldown is not None:
        bot.reply_to(message, f"Подождите {cooldown} секунд.")
        return
    log_to_telegram(message)
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    print("/start")
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    bot.reply_to(message, "Дарова чижик!\n Команды бота: /ahelp остальное сам)")

conn = sqlite3.connect('simple_guess_game.db', check_same_thread=False)
cursor = conn.cursor()

# Удаление старой таблицы (опционально, только при разработке)
cursor.execute("DROP TABLE IF EXISTS statistics")

# Создание таблицы статистики с нужными колонками
cursor.execute("""
CREATE TABLE IF NOT EXISTS statistics (
    user_id INTEGER PRIMARY KEY,
    wins INTEGER DEFAULT 0,
    shots INTEGER DEFAULT 0,
    blanks INTEGER DEFAULT 0
    
)
""")
conn.commit()














# Команда для получения фото котика
@bot.message_handler(regexp=r"(?i)^(cat|кот|кошка|китик)$")
def send_cat_picture(message):
    """Отправляет фото котика при получении сообщения с одним из указанных слов"""
    response = requests.get('https://api.thecatapi.com/v1/images/search')
    
    if response.status_code == 200:
        cat_data = response.json()
        cat_url = cat_data[0].get('url', None)
        if cat_url:
            bot.send_photo(message.chat.id, cat_url)
            print("------\n.cat")
        else:
            bot.send_message(message.chat.id, "Не удалось получить ссылку на котика 😿")
    else:
        bot.send_message(message.chat.id, "API недоступен. Попробуйте позже.")








import subprocess




def get_memory_status():
    try:
        # Команда для получения информации о памяти на Linux/Android
        result = subprocess.run(['free', '-m'], stdout=subprocess.PIPE)
        output = result.stdout.decode('utf-8').splitlines()

        # Парсим вывод команды free
        memory_info = output[1].split()
        total_memory = memory_info[1]
        used_memory = memory_info[2]
        free_memory = memory_info[3]
        memory_percent = memory_info[4]

        return f"Используемая память: {used_memory} MB / {total_memory} MB\n" \
               f"Свободная память: {free_memory} MB\n" \
               f"Процент использования: {memory_percent}%"
    except Exception as e:
        return f"Ошибка при получении информации о памяти: {e}"

# Функция для получения информации о CPU
def get_cpu_status():
    try:
        # Получаем информацию о CPU с помощью команды top
        result = subprocess.run(['top', '-bn1'], stdout=subprocess.PIPE)
        output = result.stdout.decode('utf-8').splitlines()

        # Ищем строку с данными о CPU
        for line in output:
            if line.startswith('Cpu(s)'):
                cpu_info = line.split(",")
                cpu_percent = cpu_info[0].split()[1]  # Получаем процент использования CPU
                return f"Процент использования CPU: {cpu_percent}%"
    except Exception as e:
        return f"Ошибка при получении информации о CPU: {e}"

# Команда для получения статуса сервера
@bot.message_handler(commands=["ping", "cpu", "server"])
def server_status(message):
    if message.from_user.id in owners:  # Проверка на наличие пользователя в списке владельцев
        try:
            memory_status = get_memory_status()
            cpu_status = get_cpu_status()

            status_message = (
                f"🖥️ <b>Статус сервера</b>:\n"
                f"{memory_status}\n"
                f"{cpu_status}"
            )

            # Отправка сообщения
            bot.send_message(message.chat.id, status_message, parse_mode='HTML')

        except Exception as e:
            bot.send_message(message.chat.id, f"Ошибка при получении данных: {e}")
    else:
        bot.send_message(message.chat.id, "Вы не состоите в списке доступа.")








@bot.message_handler(commands=['spam'])
def spam_handler(message):
    """Обрабатывает команду /spam и отправляет сообщения спамом."""
    try:
        args = message.text.split(maxsplit=2)
        if len(args) < 3:
            bot.send_message(message.chat.id, "Использование: /spam <количество> <текст>")
            return

        count = int(args[1])  # количество сообщений
        text = args[2]  # текст сообщения

        # Ограничение на количество отправляемых сообщений
        if count > 999:
            bot.send_message(message.chat.id, "Максимум 10 сообщений за один раз!")
            return

        for i in range(count):
            bot.send_message(message.chat.id, text)

    except ValueError:
        bot.send_message(message.chat.id, "Укажите число и текст! Пример: /spam 5 Привет!")
    except Exception as e:
        bot.send_message(message.chat.id,)

#actions
@bot.message_handler(commands=['actions'])
def send_exchange_rates(message):
    user_id = message.from_user.id
    cooldown = cooldown_handler(user_id)

    if cooldown is not None:
        bot.reply_to(message, f"Подождите {cooldown} секунд.")
        return
    log_to_telegram(message)
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    print("/actions")
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    try:
        # Получаем данные о курсах валют и биткойна
        response = requests.get("https://api.exchangerate-api.com/v4/latest/USD")
        btc_response = requests.get("https://api.coindesk.com/v1/bpi/currentprice.json")

        if response.status_code == 200 and btc_response.status_code == 200:
            data = response.json()
            btc_data = btc_response.json()

            # Курсы валют
            usd_to_uah = data['rates'].get('UAH', 'нет данных')
            usd_to_kzt = data['rates'].get('KZT', 'нет данных')
            usd_to_rub = data['rates'].get('RUB', 'нет данных')

            # Курс биткойна в USD
            btc_to_usd = btc_data['bpi']['USD']['rate']

            # Формируем сообщение
            text = (
                f"💹 *Курсы валют и криптовалют:*\n\n"
                f"💵 1 Доллар США:\n"
                f"— 🇺🇦 Гривны: {usd_to_uah} UAH\n"
                f"— 🇰🇿 Тенге: {usd_to_kzt} KZT\n"
                f"— 🇷🇺 Рубли: {usd_to_rub} RUB\n\n"
                f"₿ 1 Биткойн (BTC):\n"
                f"— {btc_to_usd} USD"
            )
        else:
            text = "❌ Не удалось получить данные о курсах валют."

        # Отправляем сообщение
        bot.reply_to(message, text)

    except Exception as e:
        bot.reply_to(message, f"❌ Произошла ошибка: {e}")

#love
@bot.message_handler(commands=['love'])
def love(message):
    user_id = message.from_user.id
    cooldown = cooldown_handler(user_id)

    if cooldown is not None:
        bot.reply_to(message, f"Подождите {cooldown} секунд.")
        return
    log_to_telegram(message)
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    print("/love")
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    try:
        # Разбиваем сообщение на слова, чтобы получить упомянутого пользователя
        mentioned_user = message.text.split()[1] if len(message.text.split()) > 1 else None
        
        if mentioned_user:
            # Генерируем случайный процент совместимости
            compatibility = random.randint(0, 100)
            bot.reply_to(message, f"💖 Совместимость с {mentioned_user}: {compatibility}%!")
        else:
            bot.reply_to(message, "❌ Пожалуйста, укажите пользователя после команды, например: /love @username.")
    except Exception as e:
        bot.reply_to(message, f"❌ Произошла ошибка: {e}")

# Команда /hero
@bot.message_handler(commands=['hero'])
def char(message):
    user_id = message.from_user.id
    cooldown = cooldown_handler(user_id)

    if cooldown is not None:
        bot.reply_to(message, f"Подождите {cooldown} секунд.")
        return
    log_to_telegram(message)
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    print("/hero")
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    name = random.choice(names)
    weapon = random.choice(weapons)
    magical_item = random.choice(magical_items)
    title = random.choice(titles)

    # Текстовое сообщение
    text = (
        f"✨ *Ваш новый персонаж* ✨\n\n"
        f"Имя: {name}\n"
        f"Оружие: {weapon}\n"
        f"Магический предмет: {magical_item}\n"
        f"Звание: {title}\n\n"
        f"Пусть приключения будут захватывающими!"
    )

    # Отправляем сообщение
    bot.reply_to(message, text)

# Активные игры для угадывания чисел
active_games = {}

# Обновление статистики побед
def update_wins(user_id):
    cursor.execute("SELECT wins FROM statistics WHERE user_id = ?", (user_id,))
    if cursor.fetchone():
        cursor.execute("UPDATE statistics SET wins = wins + 1 WHERE user_id = ?", (user_id,))
    else:
        cursor.execute("INSERT INTO statistics (user_id, wins) VALUES (?, 1)", (user_id,))
    conn.commit()

# Обновление статистики для рулетки
def update_roulette_stats(user_id, is_shot):
    cursor.execute("SELECT * FROM statistics WHERE user_id = ?", (user_id,))
    if cursor.fetchone():
        if is_shot:
            cursor.execute("UPDATE statistics SET shots = shots + 1 WHERE user_id = ?", (user_id,))
        else:
            cursor.execute("UPDATE statistics SET blanks = blanks + 1 WHERE user_id = ?", (user_id,))
    else:
        cursor.execute(
            "INSERT INTO statistics (user_id, wins, shots, blanks) VALUES (?, 0, ?, ?)",
            (user_id, 1 if is_shot else 0, 0 if is_shot else 1)
        )
    conn.commit()

# Команда "Угадай число"
@bot.message_handler(commands=['gs'])
def start_game(message):
    user_id = message.from_user.id
    cooldown = cooldown_handler(user_id)

    if cooldown is not None:
        bot.reply_to(message, f"Подождите {cooldown} секунд.")
        return
    log_to_telegram(message)
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    print("/gs")
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    chat_id = message.chat.id
    if chat_id in active_games:
        bot.reply_to(message, "🎲 Игра уже началась! Угадай число от 1 до 100.")
    else:
        number = random.randint(1, 100)
        active_games[chat_id] = number
        bot.reply_to(message, "🎲 Я загадал число от 1 до 100. Попробуй угадать!")

# Угадывание числа
@bot.message_handler(func=lambda message: message.text.isdigit())
def guess_number(message):
    
    chat_id = message.chat.id
    user_id = message.from_user.id
    if chat_id not in active_games:
        return

    guessed_number = int(message.text)
    secret_number = active_games[chat_id]
    if guessed_number == secret_number:
        bot.reply_to(message, f"🎉 Поздравляю! Ты угадал! Это было число {secret_number}.")
        update_wins(user_id)
        del active_games[chat_id]
    elif guessed_number < secret_number:
        bot.reply_to(message, "📈 Слишком мало, попробуй больше!")
    else:
        bot.reply_to(message, "📉 Слишком много, попробуй меньше!")

# Русская рулетка
@bot.message_handler(commands=['rlt'])
def roulette_game(message):
    user_id = message.from_user.id
    cooldown = cooldown_handler(user_id)

    if cooldown is not None:
        bot.reply_to(message, f"Подождите {cooldown} секунд.")
        return
    log_to_telegram(message)
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    print("/rlt")
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    user_id = message.from_user.id
    outcome = random.randint(1, 6)
    if outcome == 1:
        bot.reply_to(message, "💥 БАХ! Ты проиграл!")
        update_roulette_stats(user_id, is_shot=True)
    else:
        bot.reply_to(message, "😅 Клац! Пуля мимо, ты выжил!")
        update_roulette_stats(user_id, is_shot=False)

# Показать статистику
@bot.message_handler(commands=['stats'])
def show_stats(message):
    user_id = message.from_user.id
    cooldown = cooldown_handler(user_id)

    if cooldown is not None:
        bot.reply_to(message, f"Подождите {cooldown} секунд.")
        return
    log_to_telegram(message)
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    print("/stats")
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    user_id = message.from_user.id
    cursor.execute("SELECT wins, shots, blanks FROM statistics WHERE user_id = ?", (user_id,))
    data = cursor.fetchone()
    if data:
        wins, shots, blanks = data
        bot.reply_to(
            message,
            f"📊 Твоя статистика:\n"
            f"🏆 Победы в угадай число: {wins}\n"
            f"🔫 Выстрелы в рулетке: {shots}\n"
            f"😅 Холостые выстрелы: {blanks}"
        )
    else:
        bot.reply_to(message, "📊 У тебя пока нет статистики.")


 







@bot.message_handler(commands=['ping'])
def ping(message):
    user_id = message.from_user.id
    cooldown = cooldown_handler(user_id)

    if cooldown is not None:
        bot.reply_to(message, f"Подождите {cooldown} секунд.")
        return
    log_to_telegram(message)
    bot.reply_to(message, "Понг!")


@bot.message_handler(commands=['fact'])
def send_fact(message):
    user_id = message.from_user.id
    cooldown = cooldown_handler(user_id)

    if cooldown is not None:
        bot.reply_to(message, f"Подождите {cooldown} секунд.")
        return
    log_to_telegram(message)
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    print("/fact")
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    fact = random.choice(facts)
    bot.reply_to(message, fact)

blacklist = [123456789, "megalodon222222444"]  



@bot.message_handler(commands=['time'])
def time(message):
    user_id = message.from_user.id
    cooldown = cooldown_handler(user_id)

    if cooldown is not None:
        bot.reply_to(message, f"Подождите {cooldown} секунд.")
        return
    log_to_telegram(message)
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    print("/time")
    print("⬜⬜⬜⬜⬜⬜⬜⬜⬜")
    timezones = [
        ("Москва", "Europe/Moscow"),
        ("Нью-Йорк", "America/New_York"),
        ("Лондон", "Europe/London"),
        ("Токио", "Asia/Tokyo"),
        ("Сидней", "Australia/Sydney"),
        ("Берлин", "Europe/Berlin"),
        ("Дубай", "Asia/Dubai"),
        ("Пекин", "Asia/Shanghai"),
        ("Лос-Анджелес", "America/Los_Angeles"),
        ("Рио-де-Жанейро", "America/Sao_Paulo")
    ]

    time_info = "🌍 Время в разных часовых поясах:\n"
    for city, tz in timezones:
        now = datetime.now(pytz.timezone(tz))
        time_info += f"- {city}: {now.strftime('%H:%M:%S')}\n"

    bot.reply_to(message, time_info)


os.system("clear")
print('▄▀█ █▀ █▄▀ █▀█ █▀█ █ ▄▀█')
print('█▀█ ▄█ █░█ █▄█ █▀▄ █ █▀█')
print('') 
print('█▄▄ █▄█   █▄░█ █▀█ ▀█▀ █▀▀ █░░ ▄▀█ █▀▀ █▄▀')
print('█▄█ ░█░   █░▀█ █▄█ ░█░ █▀░ █▄▄ █▀█ █▄▄ █░█ ')

print('Логи будут высвечиватся ниже-----')
bot.polling()
